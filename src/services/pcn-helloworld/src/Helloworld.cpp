/*
 * Copyright 2018 The Polycube Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Modify these methods with your own implementation

#include "Helloworld.h"

// files generated by cmake from "Helloworld_dp_{ingress, egress}.c
#include "Helloworld_dp_egress.h"
#include "Helloworld_dp_ingress.h"

using namespace polycube::service;

struct ethhdr eth1, eth2;
struct iphdr iph1, iph2;

Helloworld::Helloworld(const std::string name, const HelloworldJsonObject &conf)
    : Cube(conf.getBase(), {helloworld_code_ingress}, {helloworld_code_egress}),
      HelloworldBase(name) {
  logger()->info("Creating Helloworld instance");
  setAction(conf.getAction());

  // initialize ports map (at this point there are not ports)
  update_ports_map();

  addPortsList(conf.getPorts());
  // initialize_crypto();
}

Helloworld::~Helloworld() {
  logger()->info("Destroying Helloworld instance");
}

void Helloworld::packet_in(Ports &port, polycube::service::PacketInMetadata &md,
                           const std::vector<uint8_t> &packet) {
    logger()->info("packet arrived to the slowpath from port {0}", port.name());

    // ペイロード部分の暗号化
    int out_len1 = 0, out_len2 = 0;
    unsigned char *modifiable_packet = const_cast<unsigned char*>(packet.data());
    struct ethhdr *eth = (struct ethhdr *)(modifiable_packet);
    struct iphdr *iph = (struct iphdr *)(modifiable_packet + sizeof(ethhdr));
    std::memcpy(&eth1, &eth2, sizeof(struct ethhdr));
    std::memcpy(&iph1, &iph2, sizeof(struct iphdr));
    // printf("source IP address: %d.%d.%d.%d\n", iph->saddr & 0xFF, (iph->saddr >> 8) & 0xFF,
    //                 (iph->saddr >> 16) & 0xFF, (iph->saddr >> 24) & 0xFF);
    // printf("dest IP address: %d.%d.%d.%d\n", iph->daddr & 0xFF, (iph->daddr >> 8) & 0xFF,
    //                   (iph->daddr >> 16) & 0xFF, (iph->daddr >> 24) & 0xFF);

    // EVP_CIPHER_CTX_reset(ctx);
    // EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);

    // if (EVP_EncryptUpdate(ctx, packet.data(), &out_len1, packet.data(), packet.size()) != 1) {
    //     logger()->error("EVP_EncryptUpdate failed");
    //     return;
    // }

    // if (EVP_EncryptFinal_ex(ctx, packet.data(), &out_len1, &out_len2) != 1) {
    //     logger()->error("EVP_EncryptFinal_ex failed");
    //     return;
    // }

    // パケットの全体サイズの調整
    // packet.resize(payload_offset + out_len1 + out_len2);

    // パケットの送信
    EthernetII p(modifiable_packet, packet.size());
    port.send_packet_out(p);
}
// int Helloworld::convert_mac(const std::string& mac_string, std::array<unsigned char, ETH_ALEN>& mac_array) {
//     int values[6];
//     if (std::sscanf(mac_string.c_str(), "%x:%x:%x:%x:%x:%x", &values[0], &values[1], &values[2], &values[3], &values[4], &values[5]) == 6) {
//         for (int i = 0; i < ETH_ALEN; ++i) {
//             mac_array[i] = static_cast<unsigned char>(values[i]);
//         }
//         return 0; // Success
//     }
//     return -1; // Error
// }
// uint32_t Helloworld::convert_ip(const std::string& ip_string) {
//     struct in_addr addr;
//     if (inet_pton(AF_INET, ip_string.c_str(), &addr) != 1) {
//         return 0; // Error
//     }
//     return addr.s_addr;
// }
// std::uint16_t Helloworld::checksum(std::uint16_t *buf, int size) {
//     std::uint32_t cksum = 0;

//     while (size > 1) {
//         cksum += *buf++;
//         size -= sizeof(std::uint16_t);
//     }

//     if (size) {
//         cksum += *reinterpret_cast<std::uint8_t*>(buf);
//     }

//     cksum = (cksum >> 16) + (cksum & 0xffff);
//     cksum += (cksum >> 16);

//     return static_cast<std::uint16_t>(~cksum);
// }


// int Helloworld::setup_hdr() {
//   // cet.ens6f0
//   std::string source_mac_string = "98:b7:85:1f:37:80";
//   std::string source_ip_string = "10.10.0.128";
//   // rinto moongen
//   std::string dest_mac_string = "00:25:90:7e:45:da";
//   std::string dest_ip_string = "10.0.1.201";
//   std::array<unsigned char, ETH_ALEN> source_mac, dest_mac;
//   if (convert_mac(source_mac_string, source_mac) != 0) {
//     printf("failed to convert source mac\n");
//     return -1;
//   }
//   if (convert_mac(dest_mac_string, dest_mac) != 0) {
//     printf("failed to convert dest mac\n");
//     return -1;
//   }
//   std::memcpy(new_ethhdr.h_source, source_mac.data(), ETH_ALEN);
//   std::memcpy(new_ethhdr.h_dest, dest_mac.data(), ETH_ALEN);
//   new_ethhdr.h_proto = htons(ETH_P_IP);
//   new_iphdr.version = 4;
//   new_iphdr.ihl = 5;
//   new_iphdr.tos = 0;
//   new_iphdr.tot_len = htons(sizeof(iphdr));
//   new_iphdr.id = htons(0);
//   new_iphdr.frag_off = htons(0x4000);
//   new_iphdr.ttl = 64;
//   new_iphdr.protocol = IPPROTO_UDP;
//   new_iphdr.check = 0;
//   new_iphdr.saddr = convert_ip(source_ip_string);
//   if (new_iphdr.saddr == 0) {
//     printf("cannot set source ip\n");
//     return -1;
//   }
//   new_iphdr.daddr = convert_ip(dest_ip_string);
//   if (new_iphdr.daddr == 0) {
//     printf("cannot set dest ip\n");
//     return -1;
//   }
//   new_iphdr.check = checksum(reinterpret_cast<std::uint16_t*>(&new_iphdr), sizeof(struct iphdr));
//   return 0;
// }

// int Helloworld::initialize_crypto() {
//     // キーの初期化（実際の使用では安全に管理する必要があります）
//   key = reinterpret_cast<unsigned char *>("0123456789abcdef");
  
//   iv = new unsigned char[iv_len];
//   if (!iv) {
//     // print_error("Failed to allocate IV");
//     return -1;
//   }
//   if (RAND_bytes(iv, iv_len) != 1) {
//     // print_error("Failed to generate random IV");
//     return -1;
//   }
//   ctx = EVP_CIPHER_CTX_new();
//   if (!ctx) {
//     // print_error("Failed to create ENV_CIPHER_CTX");
//     return -1;
//   }
//   if (EVP_EncryptInit_ex(ctx, EVP_aes_128_gcm(), NULL, NULL, NULL) != 1) {
//     // print_error("EVP_EncrptInit_ex failed");
//     return -1;
//   }
//   if (EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, iv_len, NULL) != 1) {
//     // print_error("Failed to set IV length for GCM");
//     return -1;
//   }
//   if (EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv) != 1) {
//     // print_error("Failed to initialize key and IV for GCM");
//     return -1;
//   }
//   return 0;
// }

HelloworldActionEnum Helloworld::getAction() {
  uint8_t value = get_array_table<uint8_t>("action_map").get(0x0);
  return static_cast<HelloworldActionEnum>(value);
}

void Helloworld::setAction(const HelloworldActionEnum &value) {
  uint8_t action = static_cast<uint8_t>(value);
  get_array_table<uint8_t>("action_map").set(0x0, action);
}

void Helloworld::addPorts(const std::string &name,
                          const PortsJsonObject &conf) {
  if (get_ports().size() == 2) {
    throw std::runtime_error("maximum number of ports reached");
  }

  add_port<PortsJsonObject>(name, conf);
  logger()->info("port {0} was connected", name);
  update_ports_map();
}

void Helloworld::delPorts(const std::string &name) {
  remove_port(name);
  logger()->info("port {0} was removed", name);
  update_ports_map();
}

void Helloworld::update_ports_map() {
  auto ports_table = get_array_table<uint16_t>("ports_map");
  auto ports = get_ports();
  uint32_t i = 0;

  for (auto &port: ports) {
    ports_table.set(i, port->index());
    i++;
  }

  // mark other ports as empty (UINT16_MAX means empty)
  while (i < 2) {
    ports_table.set(i, UINT16_MAX);
    i++;
  }
}
