/*
 * Copyright 2018 The Polycube Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Modify these methods with your own implementation

#include "Helloworld.h"

// files generated by cmake from "Helloworld_dp_{ingress, egress}.c
#include "Helloworld_dp_egress.h"
#include "Helloworld_dp_ingress.h"

#include "ndpi_api.h"

using namespace polycube::service;

void *automa;


Helloworld::Helloworld(const std::string name, const HelloworldJsonObject &conf)
    : Cube(conf.getBase(), {helloworld_code_ingress}, {helloworld_code_egress}),
      HelloworldBase(name) {
  logger()->info("Creating Helloworld instance");
  setAction(conf.getAction());

  // initialize ports map (at this point there are not ports)
  update_ports_map();

  addPortsList(conf.getPorts());
  setup_rule();
}

Helloworld::~Helloworld() {
  logger()->info("Destroying Helloworld instance");
}

void Helloworld::packet_in(Ports &port, polycube::service::PacketInMetadata &md,
                           const std::vector<uint8_t> &packet) {
    logger()->info("packet arrived to the slowpath from port {0}", port.name());

    // ペイロード部分の暗号化
    int out_len1 = 0, out_len2 = 0;
    unsigned char *pkt = const_cast<unsigned char*>(packet.data());
    struct ethhdr *eth = (struct ethhdr *)(pkt);
    struct iphdr *iph;
    struct ipv6hdr *iph6;
    struct tcphdr *tcph;
    struct udphdr *udph;
    struct icmphdr *icmph;
    struct icmp6hdr *icmp6h;
    int header_size = sizeof(struct ethhdr);

    if (eth->h_proto == htons(ETH_P_IP)) { 
      iph = (struct iphdr *)(pkt + sizeof(struct ethhdr));
      header_size += sizeof(struct iphdr);
      switch (iph->protocol) {
        case IPPROTO_TCP:
          tcph = (struct tcphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct iphdr));
          header_size += sizeof(struct tcphdr);
          break;
        case IPPROTO_UDP:
          udph = (struct udphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct iphdr));
          header_size += sizeof(struct udphdr);
          break;
        case IPPROTO_ICMP:
          icmph = (struct icmphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct iphdr));
          header_size += sizeof(icmph);
          break;
      }
    } else if (eth->h_proto == htons(ETH_P_IPV6)) {
      iph6 = (struct ipv6hdr *)(pkt + sizeof(struct ethhdr));
      header_size += sizeof(struct ipv6hdr);
      switch (iph6->nexthdr) {
        case IPPROTO_TCP:
          tcph = (struct tcphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct ipv6hdr));
          header_size += sizeof(struct tcphdr);
          break;
        case IPPROTO_UDP:
          udph = (struct udphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct ipv6hdr));
          header_size += sizeof(struct udphdr);
          break;
        case IPPROTO_ICMP:
          icmph = (struct icmphdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct ipv6hdr));
          header_size += sizeof(struct icmphdr);
          break;
        case IPPROTO_ICMPV6:
          icmp6h = (struct icmp6hdr *)(pkt + sizeof(struct ethhdr) + sizeof(struct ipv6hdr));
          header_size += sizeof(struct icmp6hdr);
          break;
      }
    }
    char *payload = (char *)pkt + header_size;
    *(char *)(pkt + packet.size()) = '\0';

    ndpi_match_string(automa, payload);
    swap_mac_addresses(pkt);

    // パケットの送信
    EthernetII p(pkt, packet.size());
    port.send_packet_out(p);
}

void Helloworld::swap_mac_addresses(void *pkt) {
  struct ether_header *eth = (struct ether_header *)pkt;
  struct ether_addr *src_addr = (struct ether_addr *)&eth->ether_shost;
  struct ether_addr *dst_addr = (struct ether_addr *)&eth->ether_dhost;
  struct ether_addr tmp;

  tmp = *src_addr;
  *src_addr = *dst_addr;
  *dst_addr = tmp;
}

int Helloworld::setup_rule()
{
    long long int match_total = 0;
    int ret;
    char line[1024];
    FILE *file;

    if ((automa = ndpi_init_automa()) == NULL) {
      printf("Failed to ndpi_init_automa");
      return -1;
    }

    file = fopen("/home/ehehe/NFC2024/data/daemon/NF_pool/u_dpi/rules.txt", "r");
    if (file == NULL) {
        printf("Failed to open rules.txt");
        return -1;
    }

    while (fgets(line, sizeof(line), file)) {
        // 改行文字を削除
        line[strcspn(line, "\n")] = 0;
        
        // 空行をスキップ
        if (strlen(line) == 0) {
            continue;
        }

        ret = ndpi_add_string_to_automa(automa, ndpi_strdup(line));
        if (ret < 0) {
            printf("Failed to ndpi_add_string_to_automa(%s)", line);
        }
        match_total++;
    }

    fclose(file);

    ndpi_finalize_automa(automa);

    printf("Total %lld patterns added\n", match_total);
    return 0;
}

HelloworldActionEnum Helloworld::getAction() {
  uint8_t value = get_array_table<uint8_t>("action_map").get(0x0);
  return static_cast<HelloworldActionEnum>(value);
}

void Helloworld::setAction(const HelloworldActionEnum &value) {
  uint8_t action = static_cast<uint8_t>(value);
  get_array_table<uint8_t>("action_map").set(0x0, action);
}

void Helloworld::addPorts(const std::string &name,
                          const PortsJsonObject &conf) {
  if (get_ports().size() == 2) {
    throw std::runtime_error("maximum number of ports reached");
  }

  add_port<PortsJsonObject>(name, conf);
  logger()->info("port {0} was connected", name);
  update_ports_map();
}

void Helloworld::delPorts(const std::string &name) {
  remove_port(name);
  logger()->info("port {0} was removed", name);
  update_ports_map();
}

void Helloworld::update_ports_map() {
  auto ports_table = get_array_table<uint16_t>("ports_map");
  auto ports = get_ports();
  uint32_t i = 0;

  for (auto &port: ports) {
    ports_table.set(i, port->index());
    i++;
  }

  // mark other ports as empty (UINT16_MAX means empty)
  while (i < 2) {
    ports_table.set(i, UINT16_MAX);
    i++;
  }
}
